#include <iostream>
#include <string>
#include <map>
#include <sstream>
#include <fstream>
#include <vector>
#include "game.h"
#include "info.h"
#include "direction.h"
#include "textdisplay.h"
#include "player.h"
#include "input.h"
#include "tile.h"
#include "path.h"
#include "address.h"
#include "dice.h"
using namespace std;

bool operator==(const string& s1,const string& s2){
    if (s1.length() != s2.length()) return false;
    const int l = s1.length();
    for (int i = 0;i < l;++i){
        const char& c1 = s1[i];
        const char& c2 = s2[i];
        if (c1 > 64 && c1 < 91){
            if (c1 != c2 && (c2 - c1) != 32) return false;
        } else if (c1 > 96 && c1 < 123){
            if (c1 != c2 && (c1 - c2) != 32) return false;
        }
    }
    return true;
}

SubscriptionType st = SubscriptionType::Set; // st is initialized to
// vary the num field of info generated by getInfo()

Tile::Tile():Geese{false}{}// initial (geese) state of a tile is false 

//bool Tile::buildable(Address * ad);
Info Tile::getInfo() {
    Info i;
    i.PosX = PosX;
    i.PosY = PosY;
    i.num = num;
    i.state = Geese;
    if (resource == Resource::BRICK){
        i.s = "BRICK";
    } else if (resource == Resource::ENERGY){
        i.s = "ENERGY";
    } else if (resource == Resource::GLASS){
        i.s = "GLASS";
    } else if (resource == Resource::HEAT){
        i.s = "HEAT";
    } else if (resource == Resource::WIFI){
        i.s = "WIFI";
    } else {
        i.s = "PARK";
    }
    if (st == SubscriptionType::RV || st == SubscriptionType::CL){
        // in order ro set Value and Resource or clear
        i.num = value;
        i.PosY += 2; // easier to access the place where we locate the string
    }
    return i;
}

int Tile::getValue(){
    return value;
}

void Tile::notifyObserver(SubscriptionType t){
    st = t; // in order to vary num field in Info produced by getInfo()
    observer->notify(*this,t); // basic notify
}

bool Tile::getState(){
    return Geese;
}


void Tile::setRV(Resource r,const int& i){
    resource = r;
    value = i;
    notifyObserver(SubscriptionType::RV);
}

void Tile::setCoords(const int& x,const int& y){
    PosX = x;
    PosY = y;
}

void Tile::setNum(const int &i){
    num = i;
    notifyObserver(SubscriptionType::Set); // means to set output board
}

Tile* Tile::getNearTile(Direction d){
    return nearTiles[d]; 
}

Address* Tile::getNearAd(Direction d){
    return nearAd[d];
}

void Tile::addAd(Address* a,Direction d){
    nearAd[d] = a;
}

// Add downword located tiles, including Down, LD, RD
void Tile::addDTile(Tile* t, Direction d){
    nearTiles[d] = t;
}

// add upward located tiles, including Up, RU, LU
void Tile::addTile(Direction d, Tile* t){
    nearTiles[d] = t;
    if (d == Direction::Up){
        t->addDTile(this,Direction::Down);
        Address* a1 = t->getNearAd(Direction::LD);
        // add the LD located address for the other tile
        Address* a2 = t->getNearAd(Direction::RD);
        // add theRLD located address for the other tile
        addAd(a1,Direction::LU);
        addAd(a2,Direction::RU);
        nearPaths.emplace_back(a1->sharedPath(a2));
        // add the shared path by the two above addresses
    } else if (d == Direction::LU){
        t->addDTile(this,Direction::RD);
        Address* a1 = t->getNearAd(Direction::Right);
        Address* a2 = t->getNearAd(Direction::RD);
        addAd(a1,Direction::LU);
        addAd(a2,Direction::Left);
        nearPaths.emplace_back(a1->sharedPath(a2));
    } else if (d == Direction::RU){
        t->addDTile(this,Direction::LD);
        Address* a1 = t->getNearAd(Direction::Left);
        Address* a2 = t->getNearAd(Direction::LD);
        addAd(t->getNearAd(Direction::Left),Direction::RU);
        addAd(t->getNearAd(Direction::LD),Direction::Right);
        nearPaths.emplace_back(a1->sharedPath(a2));
    }
}

void Tile::geese(Player* p){
    if (Geese == true){
        Geese = false; // switch the state
    } else {
        Geese = true;
        vector <Player*> vp;
        bool cansteal = false; // initially cannot steal
        for (auto &ad : nearAd){
            Player* p1 = ad.second->getOwner();
            // get the address's owner, if it has one
            if (p1 != nullptr && p1 != p){
            // the current player cannot steal from no one and himself/herself
                if (vp.size() == 0){// no potential name added
                    vp.emplace_back(p1);
                } else {
                    bool sa = true; // should add p1 or not
                    for (auto it : vp){// access every addresses
                        if (it == p1){
                            sa = false;
                            // no need to add this player, since he/she has already been added
                        }
                    }
                    if (sa){
                        vp.emplace_back(p1);
                        // add it, if it has not been added before
                        sa = true; // reset it back to true
                    }
                }
            }
        }
        if (vp.size() == 0){ // you can steal from no one
            cout << "Builder " << p->getColour();
            cout << " has no builders to steal from." << endl;
        } else {
            cansteal = true; 
            // enable current player to steal,
            // since someone other than this one has the right to do so
            cout << "Builder " << p->getColour() << " can choose to steal from";
            for (auto & vpp : vp){
                cout << " " << vpp->getColour();
                // print the players that the current one can steal from
            }
            cout << endl;
        }
        if (cansteal){
            cout << "Choose a builder to steal from." << endl;
            string s;
            while (true){
                cerr << ">";
                cin >> s;// get the name of the poor fellow
                cin.exceptions(ios::failbit|ios::eofbit);
                bool breakable = false;
                for (auto& vpp : vp){
                    if (vpp->getColour() == s){
                        breakable = true; // get the other one
                        p->steal(vpp);// steal starts
                        break;
                    }
                }
                if (breakable){
                    break;
                }
            }
        }
    }
    notifyObserver(SubscriptionType::Geese);
}

void Tile::clear(){
    if (getState() == true){ // clear geese
        notifyObserver(SubscriptionType::Geese);
    }
    notifyObserver(SubscriptionType::CL); // clear the tile
}


// this function will only be called when the game was being initialized
void Tile::fillAd(vector <Address*>& va, vector <Path*>& vp, TextDisplay* td){
    if (getNearAd(Direction::LU) == nullptr){
        Address* a = new Address(PosX - 5, PosY - 2);
        addAd(a,Direction::LU);// locate the LeftUpper address
        va.emplace_back(a); // add the address
        a->attach(td);// attach observer
        a->notifyObserver(SubscriptionType::SetAd);// set Ad
        Address* a1 = getNearAd(Direction::RU);
        if (a1 != nullptr){
        // you got the RightUpper address, thus a pth between the two is needed
            Path* p = new Path(PosX, PosY - 2);
            vp.emplace_back(p);// add the path to the tile
            p->attach(td);// attach observer
            a->addPath(p);// add path to one of the end of its
            a1->addPath(p); // add path to its the other end
            p->addAds(a); // add address to the path
            p->addAds(a1); // add the address to the path
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPH); // set horizontal path
        }
        a1 = getNearAd(Direction::Left); // for another combining address
        if (a1 != nullptr){
            Path *p = new Path(PosX - 5, PosY);
            vp.emplace_back(p);
            p->attach(td);
            a->addPath(p);
            a1->addPath(p);
            p->addAds(a);
            p->addAds(a1);
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPV); // set vertical path
        }
    }
    if (getNearAd(Direction::RU) == nullptr){
        Address *a = new Address(PosX + 5, PosY - 2);
        addAd(a,Direction::RU); // ?
        va.emplace_back(a);
        a->attach(td);
        a->notifyObserver(SubscriptionType::SetAd);
        Address* a1 = getNearAd(Direction::LU);
        Path* p = new Path(PosX, PosY - 2);// LU is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        p->notifyObserver(SubscriptionType::SetPH);
        a1 = getNearAd(Direction::Right);
        if (a1 != nullptr){
            p = new Path(PosX + 5, PosY);
            vp.emplace_back(p);
            p->attach(td);
            a->addPath(p);
            a1->addPath(p);
            p->addAds(a);
            p->addAds(a1);
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPV);
        }
    }
    if (getNearAd(Direction::Left) == nullptr){
        Address *a = new Address(PosX - 5, PosY + 2);
        addAd(a,Direction::Left);
        va.emplace_back(a);
        a->attach(td);
        a->notifyObserver(SubscriptionType::SetAd);
        Address* a1 = getNearAd(Direction::LU);
        Path* p = new Path(PosX - 5, PosY);// LU is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        p->notifyObserver(SubscriptionType::SetPV);
        a1 = getNearAd(Direction::LD);
        if (a1 != nullptr){
            p = new Path(PosX - 5, PosY + 4);
            vp.emplace_back(p);
            p->attach(td);
            a->addPath(p);
            a1->addPath(p);
            p->addAds(a);
            p->addAds(a1);
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPV);
        }
    }
    if (getNearAd(Direction::Right) == nullptr){
        Address *a = new Address(PosX + 5, PosY + 2);
        addAd(a,Direction::Right);
        va.emplace_back(a);
        a->attach(td);
        a->notifyObserver(SubscriptionType::SetAd);
        Address* a1 = getNearAd(Direction::RU);
        Path* p = new Path(PosX + 5, PosY);// RU is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        p->notifyObserver(SubscriptionType::SetPV);
        a1 = getNearAd(Direction::RD);
        if (a1 != nullptr){
            p = new Path(PosX + 5, PosY + 4);
            vp.emplace_back(p);
            p->attach(td);
            a->addPath(p);
            a1->addPath(p);
            p->addAds(a);
            p->addAds(a1);
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPV);
        }
    }
    if (getNearAd(Direction::LD) == nullptr){
        Address *a = new Address(PosX - 5, PosY + 6);
        addAd(a,Direction::LD);
        va.emplace_back(a);
        a->attach(td);
        Address* a1 = getNearAd(Direction::Left);
        Path* p = new Path(PosX - 5, PosY + 4);// Left is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        a->notifyObserver(SubscriptionType::SetAd);
        p->notifyObserver(SubscriptionType::SetPV);
        a1 = getNearAd(Direction::RD);
        if (a1 != nullptr){
            p = new Path(PosX, PosY + 6);
            vp.emplace_back(p);
            p->attach(td);
            a->addPath(p);
            a1->addPath(p);
            p->addAds(a);
            p->addAds(a1);
            nearPaths.emplace_back(p);
            p->notifyObserver(SubscriptionType::SetPH);
        }
    }
    if (getNearAd(Direction::RD) == nullptr){
        Address *a = new Address(PosX + 5, PosY + 6);
        addAd(a,Direction::RD);
        va.emplace_back(a);
        a->attach(td);
        a->notifyObserver(SubscriptionType::SetAd);
        Address* a1 = getNearAd(Direction::LD);
        Path* p = new Path(PosX, PosY + 6); // LD is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        p->notifyObserver(SubscriptionType::SetPH);
        a1 = getNearAd(Direction::Right);
        p = new Path(PosX + 5, PosY + 4); // Right is there
        vp.emplace_back(p);
        p->attach(td);
        a->addPath(p);
        a1->addPath(p);
        p->addAds(a);
        p->addAds(a1);
        nearPaths.emplace_back(p);
        p->notifyObserver(SubscriptionType::SetPV);
    }
}

// transfer a string to its resource type
Resource StringToResource(const string& s){
    if (s == "BRICK"){
        return Resource::BRICK;
    } else if (s == "WIFI"){
       return Resource::WIFI;
    } else if (s == "ENERGY"){
        return Resource::ENERGY;
    } else if (s == "GLASS"){
        return Resource::GLASS;
    } else if (s == "HEAT"){
        return Resource::HEAT;
    }
    return Resource::PARK;
}

// where the main game id played
void Tile::TakePlayer(Player *p, Game &g){
    if (resource != Resource::PARK){
        int count = 0;
        for (auto &ad : nearAd){
            if (ad.second->getOwner() == p){
                ++count; // count the number of resource one can have 
                         // inside the current tile
            }
        }
        if (count != 0){ 
        // if the player can receive some resource, 
        //then a message will be printed
            cout << "Builder " << p->getColour() << " gained:" << endl;
            cout << count << " ";
            if (resource == Resource::BRICK){
                cout << "brick" << endl;
            } else if (resource == Resource::GLASS){
                cout << "glass" <<endl;
            } else if (resource == Resource::HEAT){
                cout << "heat" << endl;
            } else if (resource == Resource::ENERGY){
                cout << "energy" << endl;
            } else{
                cout << "WiFi" << endl;
            }
        }
        p->receive(resource,count); // receive the resource
    }
    string s;
    while (true){
        cerr << ">";
        cin >> s;
        cin.exceptions(ios::failbit|ios::eofbit);
        if (s == "board"){
            g.print(); // print the board 
        } else if (s == "status"){
            g.printStatus();
        } else if (s == "residences"){
            p->printRes();
        } else if (s == "build-res"){
            int i;
            Address *ad = nullptr;
            cin >> i;
            cin.exceptions(ios::eofbit);
            if (cin.fail()){ // print a warning message
                cerr << "Invalid Input"<< endl;
                cerr << "Please enter an integer" << endl;
                cin.clear();// clear in order to continue reading another input
                cin.ignore();
            } else {
                for (auto &a : nearAd){ // make sure the tile is inside the tile
                    Info info = a.second->getInfo();
                    if (info.num == i){
                        ad = a.second;
                    }
                }
                if (ad != nullptr) { // if the address is inside the tile
                    p->buildBase(ad);
                } else {
                    cerr << "Please choose a place inside the tile" << endl;
                }
            }
        } else if (s == "build-road"){
            int i;
            cin >> i;
            //for (auto it : nearPaths){
              //  Info info = it->getInfo();
                //cout << info.num << endl;
            //}
            cin.exceptions(ios::eofbit);
            if (cin.fail()){
                cerr << "Invalid Input"<< endl;
                cerr << "Please enter an integer" << endl;
                cin.clear();
                cin.ignore();
            }else {
                bool nothere = true; // whether the place is inside the tile
                for (auto &path : nearPaths){
                    Info info = path->getInfo();
                    if (info.num == i){
                        nothere = false; 
                        p->buildRoad(path);
                    }
                }
                if (nothere){
                    cerr << "Please choose a place inside the tile" << endl;
                }
            }
        } else if (s == "improve"){
            int i;
            cin >> i;
            cin.exceptions(ios::eofbit);
            if (cin.fail()){
                cerr << "Invalid Input"<< endl;
                cerr << "Please enter an integer" << endl;
                cin.clear();
                cin.ignore();
            }else {
                Address *ad = nullptr;
                for (auto &a : nearAd){
                    Info info = a.second->getInfo();
                    if (info.num == i){
                        ad = a.second;
                    }
                }
                if (ad != nullptr) {
                    p->improve(ad);
                } else {
                    cerr << "Please choose a place inside the tile" << endl;
                }
            }
        } else if (s == "trade"){
            cin >> s;
            cin.exceptions(ios::failbit|ios::eofbit);
            Player* p2 = g.getPlayer(s);
            if (p2 == p){
                cerr << "Cannot Trade to yourself" << endl;
            }else if (p2 == nullptr){
                cerr << "Builder " << s << " does not exist" << endl;
            }else {
                string Stake;
                string Sgive;
                cin >> Stake >> Sgive;
                cin.exceptions(ios::failbit|ios::eofbit);
                Resource take = StringToResource(s);
                Resource give = StringToResource(s);
                if (take == Resource::PARK){
                    cerr << "Please choose a tradible resource" << endl;
                } else if ( give == Resource::PARK){
                    cerr << "Please choose a tradible resource" << endl;
                } else {
                    cerr << p->getColour() << " offers " << p2->getColour();
                    cout << " one " << Sgive << " for one " << Stake << ".";
                    cout << endl;
                    cout << "Does " << p2->getColour() << " accept this offer?" << endl;
                    while (true){
                        cerr << ">";
                        cin >> s;
                        cin.exceptions(ios::failbit|ios::eofbit);
                        if (s == "yes"){ // agree to trade
                            p->Trade(p2,give,take);
                            break;
                        } else if (s == "no"){ // refuse the trade
                            cerr << p2->getColour() << " refused to trade with you." << endl;
                            cerr << "Sorry" << endl;
                            break;
                        }
                    }
                }
            }
        }
        else if (s == "next"){ // next player
            return;
        } else if (s == "save"){ // save the current game
            cin >> s;
            cin.exceptions(ios::failbit|ios::eofbit);
            ofstream outfile(s);
            g.save(outfile);
            outfile.close();
        } else if (s == "help"){ // print all possible inputs
            cout << "Valid commands:" << endl;
            cout << "board" << endl;
            cout << "status" << endl;
            cout <<"residences" << endl;
            cout << "build-road <path#>" << endl;
            cout << "build-res <housing#>" << endl;
            cout << "improve <housing#>" << endl;
            cout << "trade <colour> <give> <take>" << endl;
            cout << "next" << endl;
            cout << "save <file>" << endl;
            cout << "help" << endl;
        } else {
            cerr << "Invalid input." << endl;
        }
    }
}

Tile::~Tile(){  }

